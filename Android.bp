package {
    default_applicable_licenses: ["external_rust_crates_mmtk-core_license"],
}

license {
    name: "external_rust_crates_mmtk-core_license",
    visibility: [":__subpackages__"],
    license_kinds: [
        "SPDX-license-identifier-Apache-2.0",
        "SPDX-license-identifier-MIT",
    ],
    license_text: [
        "LICENSE-APACHE",
        "LICENSE-MIT",
    ],
}

rust_library {
    name: "libmmtk",
    host_supported: true,
    prefer_rlib: true,
    crate_name: "mmtk",
    cargo_env_compat: true,
    cargo_pkg_version: "0.30.0",
    srcs: ["src/lib.rs"],
    edition: "2021",
    features: [
        "default",
        "vm_space",
        "nogc_trace",
        "perf_counter",
        // "eager_zeroing",
        "single_worker",                    // Single-threaded build
        "eager_sweeping",
        // "edge_enqueuing",                // Multi-threaded build
        "object_pinning",
        // "semispace_fixed_size",
        "builtin_env_logger",               // This is technically only used by the x86_64 headless build
        "set_unlog_bits_vm_space",
        // "atrace_heap_size_breakdown",
        // "dont_enqueue_vm_space_objects",
        // "sanity",                        // debug only
        // XXX(kunals): There's an extremely subtle pitfall with "poison_on_release" + "single_worker" wherein
        // we try to poison memory for a large object but its class has already been moved (or is dead itself)
        // and we've poisoned the old class address already. In that case, we can't get the current size of the
        // large object because we have no type information. A simple hack could be to release large objects
        // before any other space. Technically this could be an issue for the multi-threaded build as well, but
        // the work packets + OS scheduler need to be scheduled in such a way to make this happen.
        // "poison_on_release",             // debug only
        // "extreme_assertions",            // debug only
    ],
    // "debug" build
    flags: [
        "-C opt-level=0",
        "-C debuginfo=2",
        "-C strip=none",
        "-C debug-assertions=true",
        "-C overflow-checks=true",
        "-C codegen-units=256",
    ],
    // "release" build
    // flags: [
    //     "-C opt-level=3",
    //     "-C debuginfo=0",
    //     "-C strip=symbols",
    //     "-C debug-assertions=false",
    //     "-C overflow-checks=false",
    //     "-C codegen-units=16",
    // ],
    rustlibs: [
        "libatomic_rust",
        "libatomic_refcell",
        "libatomic_traits",
        "libatrace_rust",
        "libbytemuck",
        "libcfg_if",
        "libcrossbeam_deque",
        "libcrossbeam_queue",
        "libdowncast_rs",
        "libenum_map",
        "libitertools",
        "liblazy_static",
        "liblibc",
        "liblog_rust",
        "libmemoffset",
        "libnum_cpus",
        "libnum_traits",
        "libperf_event",
        "libportable_atomic",
        "libprobe",
        "libregex",
        "libspin",
        "libstatic_assertions",
        "libstrum",
        "libsysinfo",
    ],
    proc_macros: [
        "libdelegate",
        "libmmtk_macros",
        "libstrum_macros",
    ],
    target: {
        android: {
            rustlibs: [
                "libandroid_logger", // only on APEX builds
            ],
        },
        host: {
            rustlibs: [
                "libenv_logger", // only on headless builds
            ],
        },
    },
    apex_available: [
        "//apex_available:platform",
        "//apex_available:anyapex",
    ],
    product_available: true,
    vendor_available: true,
    min_sdk_version: "31",
}

rust_proc_macro {
    name: "libmmtk_macros",
    crate_name: "mmtk_macros",
    cargo_env_compat: true,
    cargo_pkg_version: "0.30.0",
    srcs: ["macros/src/lib.rs"],
    edition: "2021",
    rustlibs: [
        "libproc_macro2",
        "libproc_macro_error",
        "libquote",
        "libsyn",
    ],
    product_available: true,
    vendor_available: true,
}
